;; Standard library for FunC
;; This file contains essential functions and constants for TON smart contracts

;; =============== CONSTANTS ===============

;; Error codes
const int INVALID_OP = 0xffff;
const int ACCESS_DENIED = 401;
const int CONTRACT_STOPPED = 403;
const int INVALID_COMMENT = 404;

;; Message modes
const int NORMAL = 0;
const int PAID_EXTERNALLY = 1;
const int IGNORE_ERRORS = 2;
const int DESTROY_IF_ZERO = 32;
const int CARRY_REMAINING_GAS = 64;
const int CARRY_REMAINING_BALANCE = 128;

;; Address constants
const slice HOLE_ADDRESS = "EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c"a;
const int BOUNCEABLE = 0x18;
const int NON_BOUNCEABLE = 0x10;

;; =============== UTILITY FUNCTIONS ===============

;; Check if slice is empty
int slice_empty?(slice s) asm "SEMPTY";

;; Load address from slice
slice load_msg_addr(slice s) asm( -> 1 0) "LDMSGADDR";

;; Store address to builder
builder store_slice(builder b, slice s) asm "STSLICER";

;; Calculate cell hash
int cell_hash(cell c) asm "HASHCU";

;; Get my address
slice my_address() asm "MYADDR";

;; Get balance
int get_balance() asm "BALANCE" "FIRST";

;; =============== MATH FUNCTIONS ===============

;; Minimum of two integers
int min(int a, int b) {
    return a < b ? a : b;
}

;; Maximum of two integers  
int max(int a, int b) {
    return a > b ? a : b;
}

;; Absolute value
int abs(int a) {
    return a < 0 ? -a : a;
}

;; =============== SLICE OPERATIONS ===============

;; Check if two slices are equal
int equal_slices(slice a, slice b) asm "SDEQ";

;; Skip bits in slice
slice skip_bits(slice s, int len) asm "SDSKIPFIRST";

;; Get slice bits
int slice_bits(slice s) asm "SBITS";

;; Get slice refs
int slice_refs(slice s) asm "SREFS";

;; =============== BUILDER OPERATIONS ===============

;; Get builder bits
int builder_bits(builder b) asm "BBITS";

;; Get builder refs  
int builder_refs(builder b) asm "BREFS";

;; Store reference
builder store_ref(builder b, cell c) asm(c b) "STREF";

;; Store coins (varuint16)
builder store_coins(builder b, int x) asm "STGRAMS";

;; Store uint with specified bits
builder store_uint(builder b, int x, int len) asm(x len b) "STUX";

;; Store int with specified bits
builder store_int(builder b, int x, int len) asm(x len b) "STIX";

;; =============== CELL OPERATIONS ===============

;; Load reference from slice
cell load_ref(slice s) asm( -> 1 0) "LDREF";

;; Load coins from slice
int load_coins(slice s) asm( -> 1 0) "LDGRAMS";

;; Load uint from slice
int load_uint(slice s, int len) asm(s len -> 1 0) "LDUX";

;; Load int from slice
int load_int(slice s, int len) asm(s len -> 1 0) "LDIX";

;; Begin cell
builder begin_cell() asm "NEWC";

;; End cell
cell end_cell(builder b) asm "ENDC";

;; Begin parse
slice begin_parse(cell c) asm "CTOS";

;; =============== DICTIONARY OPERATIONS ===============

;; Store dictionary
builder store_dict(builder b, cell dict) {
    if (null?(dict)) {
        return b.store_int(0, 1);
    } else {
        return b.store_int(1, 1).store_ref(dict);
    }
}

;; Load dictionary
(slice, cell) load_dict(slice s) {
    int has_dict = s~load_int(1);
    if (has_dict) {
        return (s, s~load_ref());
    } else {
        return (s, null());
    }
}

;; =============== MESSAGE OPERATIONS ===============

;; Send raw message
() send_raw_message(cell msg, int mode) impure asm "SENDRAWMSG";

;; Random number generation
int random() impure asm "RANDU256";

;; Current time
int now() asm "NOW";

;; Block logical time
int block_lt() asm "BLOCKLT";

;; =============== STORAGE OPERATIONS ===============

;; Get contract data
cell get_data() asm "c4 PUSH";

;; Set contract data
() set_data(cell c) impure asm "c4 POP";

;; =============== EXCEPTION HANDLING ===============

;; Throw exception
() throw(int exit_code) impure asm "THROW";

;; Throw exception unless condition
() throw_unless(int exit_code, int condition) impure asm "THROWARGIFNOT";

;; Throw exception if condition
() throw_if(int exit_code, int condition) impure asm "THROWARGIF";

;; =============== COMPUTATION LIMITS ===============

;; Accept message (for external messages)
() accept_message() impure asm "ACCEPT";

;; Set gas limit
() set_gas_limit(int limit) impure asm "SETGASLIMIT";

;; Commit current state
() commit() impure asm "COMMIT";

;; =============== PRECOMPILED ADDRESSES ===============

;; Check workchain
int is_same_workchain(slice addr) {
    return addr.preload_uint(2) == 2;  ;; std_address tag
}

;; Load workchain and address hash
(int, int) parse_std_addr(slice addr) {
    (int wc, slice hash_part) = addr.load_int(8).load_uint(256);
    return (wc, hash_part);
}

;; Preload uint without consuming slice
int preload_uint(slice s, int len) asm(s len -> 1 0) "PLDUX";

;; =============== TVM ASSEMBLY HELPERS ===============

;; Null check
int null?(cell c) asm "ISNULL";

;; Tuple operations
tuple empty_tuple() asm "NIL";
tuple tpush(tuple t, cell c) asm "TPUSH";
(tuple, cell) tpop(tuple t) asm "TPOP";

;; Force any to int (unsafe)
int force_cast_to_int(slice s) asm "NOP";

;; =============== VALIDATION HELPERS ===============

;; Validate message address format
int is_valid_addr(slice addr) {
    if (addr.slice_empty?()) { return false; }
    int addr_type = addr.preload_uint(2);
    return (addr_type == 2) | (addr_type == 3); ;; std_address or var_address
}

;; Check if address is hole address
int is_hole_address(slice addr) {
    return equal_slices(addr, HOLE_ADDRESS);
}

;; =============== WORKCHAIN VALIDATION ===============

;; Validate that address is in basechain (workchain 0)
() force_chain(slice addr) impure {
    (int wc, _) = parse_std_addr(addr);
    throw_unless(333, wc == 0);
}