import { Address, beginCell, Cell, contractAddress, StateInit, storeStateInit, toNano } from '@ton/core';
import { compile } from '@ton/blueprint';

// Token metadata
const JETTON_CONTENT = {
    name: "TON TON Token",
    symbol: "TTKN",
    decimals: "9",
    description: "TON TON Token with 2% transaction fee and buyback mechanism",
    image: "https://your-domain.com/ttkn-logo.png"
};

// Convert metadata to cell
function createJettonContent(content: any): Cell {
    return beginCell()
        .storeUint(0, 8) // onchain content tag
        .storeDict(
            Object.entries(content).reduce((dict, [key, value]) => {
                dict.set(
                    beginCell().storeBuffer(Buffer.from(key)).endCell(),
                    beginCell().storeBuffer(Buffer.from(String(value))).endCell()
                );
                return dict;
            }, new Map())
        )
        .endCell();
}

async function deployJetton() {
    // Compile contracts
    const jettonMinterCode = await compile('jetton-minter');
    const jettonWalletCode = await compile('jetton-wallet');
    
    // Admin address (replace with your address)
    const adminAddress = Address.parse("EQD__ADDRESS_HERE__"); // Replace with actual address
    
    // Initial supply: 2.1 billion tokens
    const totalSupply = BigInt("2100000000000000000"); // 2.1B * 10^9 decimals
    
    // Create jetton content
    const jettonContent = createJettonContent(JETTON_CONTENT);
    
    // Create initial data for minter
    const minterData = beginCell()
        .storeCoins(0) // total_supply starts at 0, will be set when minting
        .storeBit(true) // mintable
        .storeAddress(adminAddress) // admin_address
        .storeRef(jettonContent) // jetton_content
        .storeRef(jettonWalletCode) // jetton_wallet_code
        .endCell();
    
    // Create state init for minter
    const minterStateInit: StateInit = {
        code: jettonMinterCode,
        data: minterData
    };
    
    // Calculate minter address
    const minterAddress = contractAddress(0, minterStateInit);
    
    console.log("Jetton Minter Address:", minterAddress.toString());
    console.log("Admin Address:", adminAddress.toString());
    console.log("Total Supply:", totalSupply.toString());
    
    // Deploy commands for TON CLI or other deployment tools
    console.log("\n=== Deployment Instructions ===");
    console.log("1. Save the minter code and data to files");
    console.log("2. Deploy using ton-cli or your preferred method");
    console.log("3. Send initial mint transaction to create the total supply");
    
    // Mint transaction body for initial supply
    const mintBody = beginCell()
        .storeUint(21, 32) // op::mint
        .storeUint(0, 64) // query_id
        .storeAddress(adminAddress) // to_address (mint to admin)
        .storeCoins(totalSupply) // jetton_amount
        .endCell();
    
    console.log("\n=== Initial Mint Transaction ===");
    console.log("To:", minterAddress.toString());
    console.log("Amount: 0.1 TON");
    console.log("Body (base64):", mintBody.toBoc().toString('base64'));
    
    return {
        minterAddress,
        minterStateInit,
        jettonWalletCode,
        mintBody
    };
}

// Testing functions
async function testJettonOperations() {
    console.log("\n=== Testing Guide ===");
    console.log("After deployment, you can test the following operations:");
    
    console.log("\n1. Check jetton data:");
    console.log("   get_jetton_data() method on minter contract");
    
    console.log("\n2. Get wallet address:");
    console.log("   get_wallet_address(owner_address) method on minter contract");
    
    console.log("\n3. Transfer tokens (with 2% fee):");
    const transferBody = beginCell()
        .storeUint(0xf8a7ea5, 32) // op::transfer
        .storeUint(0, 64) // query_id
        .storeCoins(toNano("1000")) // 1000 tokens
        .storeAddress(Address.parse("EQD__RECIPIENT_ADDRESS__")) // to_owner_address
        .storeAddress(Address.parse("EQD__YOUR_ADDRESS__")) // response_address
        .storeCoins(toNano("0.01")) // forward_ton_amount
        .storeUint(0, 1) // forward_payload empty
        .endCell();
    
    console.log("   Transfer body (base64):", transferBody.toBoc().toString('base64'));
    
    console.log("\n4. Burn tokens:");
    const burnBody = beginCell()
        .storeUint(0x595f07bc, 32) // op::burn
        .storeUint(0, 64) // query_id
        .storeCoins(toNano("100")) // 100 tokens to burn
        .storeAddress(Address.parse("EQD__YOUR_ADDRESS__")) // response_address
        .endCell();
    
    console.log("   Burn body (base64):", burnBody.toBoc().toString('base64'));
    
    console.log("\n=== Fee Mechanism ===");
    console.log("- 2% fee is applied on each transfer");
    console.log("- 50% of fee goes to buyback (burns tokens)");
    console.log("- 50% of fee goes to treasury (currently also burned)");
    console.log("- Buyback threshold: 10,000 TON equivalent");
}

// Contract verification
function verifyContracts() {
    console.log("\n=== Contract Features ===");
    console.log("✅ TEP-74 compliant jetton standard");
    console.log("✅ 2% transaction fee on transfers");
    console.log("✅ Automatic buyback and burn mechanism");
    console.log("✅ Admin controls (mint, change admin, change content)");
    console.log("✅ Proper gas handling and error codes");
    console.log("✅ Security checks and validations");
    console.log("✅ Get methods for querying state");
    
    console.log("\n=== Security Features ===");
    console.log("✅ Admin-only minting");
    console.log("✅ Wallet address validation");
    console.log("✅ Proper gas consumption limits");
    console.log("✅ Bounce message handling");
    console.log("✅ Integer overflow protection");
    console.log("✅ Proper error handling");
}

// Main execution
async function main() {
    try {
        await deployJetton();
        await testJettonOperations();
        verifyContracts();
        
        console.log("\n=== Next Steps ===");
        console.log("1. Replace placeholder addresses with real addresses");
        console.log("2. Test on testnet first");
        console.log("3. Audit the contracts before mainnet deployment");
        console.log("4. Set up monitoring for the buyback mechanism");
        console.log("5. Consider implementing a treasury wallet for fee collection");
        
    } catch (error) {
        console.error("Error:", error);
    }
}

// Export for use in other scripts
export { deployJetton, testJettonOperations, verifyContracts, JETTON_CONTENT };

// Run if called directly
if (require.main === module) {
    main();
}